<?php
echo "<br> Магические методы <hr>";
class User {
  private $name;
  private $age;

  // при попытке обратиться к private, protected или несуществующему свойству метод __get перехватит и обработает обращение согласно коду, указанному в данном методе
  // ! при обращении к несуществующему свойству создаст его абстакцию
  public function __get($prop) { // принимает аргументом наименование необходимой для получения переменной
    return $this->$prop; // ссылаемся не на значение внешней переменной, в на значение переменной, переданной как аргумент методу
  }
  // при попытке переопределить private, protected или несуществующее свойство метод __set перехватит и обработает обращение согласно коду, указанному в данном методе
  // ! может переопределять значение несуществующего свойства
  public function __set($prop, $value) { // принимает аргументами название необходимой для переопределения переменной и значение, которое необходимо переопределить
      $this->$prop=$value;
    }
}
$a=new User();
$a->name="anatoliy";
$a->age=30;
echo $a->name;
echo $a->age;

// class Arr
// {
//   private $numbers=[];
//   protected $var;
  
//   public function addNum($num) {
//     $this->numbers[]=$num;
//     return $this; // возврат для использования последовательного вызова методов
//   }
//   // определение магического метода
//   // при попытке обратиться к private, protected или несуществующему свойству метод __get перехватит и обработает обращение согласно коду, указанному в данном методе
//   public function __get($name) {
//     return $this->var;
//   }
//   public function getNum() {
//     return $this->numbers;
//   }
  
//   public function sumNum() {
//     return array_sum($this->numbers);
//   }
//   // определение магического метода
//   // при попытке получить новый экземпляр класса выведет результат метода __toString в формате строки
//   public function __toString() {
//     return (string) array_sum($this->numbers);
//   }

// }
// $a=new Arr();
// // var_dump($a->addNum(1)->addNum(2)->getNum()); // последовательный вызов методов: в итоге будет выведен результат последнего вызванного метода
// $a->addNum(1)->addNum(2)->addNum(3);
// // print_r($a->numbers);
// // print_r($a->var);
// // print_r($a->numb);
